# diff generated by `git diff upstream/main...HEAD`
diff --git a/_CoqProject b/_CoqProject
index ca75797..06d7a242 100644
--- a/_CoqProject
+++ b/_CoqProject
@@ -94,6 +94,9 @@ theories/Crypt/nominal/Share.v
 theories/Crypt/nominal/Sep.v
 theories/Crypt/nominal/Adv.v
 theories/Crypt/nominal/NominalPrelude.v
+theories/Crypt/nominal/packages/Async.v
+theories/Crypt/nominal/packages/TotalProbability.v
+theories/Crypt/nominal/packages/HybridArgument.v
 
 # Examples of assumptions
 theories/Crypt/examples/Assumptions/DDH.v
@@ -118,6 +121,8 @@ theories/Crypt/examples/PolynomialUtils.v
 theories/Crypt/examples/PKE/Scheme.v
 theories/Crypt/examples/PKE/CyclicGroup.v
 theories/Crypt/examples/PKE/LDDH.v
+theories/Crypt/examples/PKE/OneToMany.v
+theories/Crypt/examples/PKE/MultiInstance.v
 theories/Crypt/examples/PKE/ElGamal.v
 
 # Examples from https://github.com/Som1Lse/joy-of-ssprove
diff --git a/theories/Crypt/examples/PKE/ElGamal.v b/theories/Crypt/examples/PKE/ElGamal.v
index f8c7c21..82b8ede 100644
--- a/theories/Crypt/examples/PKE/ElGamal.v
+++ b/theories/Crypt/examples/PKE/ElGamal.v
@@ -15,11 +15,11 @@ Set Bullet Behavior "Strict Subproofs".
 Set Default Goal Selector "!".
 Set Primitive Projections.
 
-From SSProve.Crypt Require Import NominalPrelude.
+From SSProve.Crypt Require Import NominalPrelude TotalProbability HybridArgument.
 Import PackageNotation.
 #[local] Open Scope package_scope.
 
-From SSProve.Crypt.examples.PKE Require Import Scheme CyclicGroup LDDH.
+From SSProve.Crypt.examples.PKE Require Import Scheme CyclicGroup LDDH OneToMany MultiInstance.
 
 Import PKE GroupScope.
 #[local] Open Scope F_scope.
@@ -33,30 +33,23 @@ Definition elgamal : scheme := {|
   ; Pub := 'el G
   ; Mes := 'el G
   ; Cip := 'el G × 'el G
-  ; sample_Cip :=
-    {code
+  ; sample_Cip := {code
       c₁ ← sample uniform #|el G| ;;
       c₂ ← sample uniform #|el G| ;;
-      ret (c₁, c₂)
-    }
-  ; keygen :=
-    {code
+      ret (c₁, c₂) }
+  ; keygen := {code
       sk ← sample uniform #|exp G| ;;
-      ret (sk, 'g ^ sk)
-    }
-  ; enc := λ pk m,
-    {code
+      ret (sk, 'g ^ sk) }
+  ; enc := λ pk m, {code
       r ← sample uniform #|exp G| ;;
-      ret ('g ^ r, m * (pk ^ r))
-    }
+      ret ('g ^ r, m * (pk ^ r)) }
   ; dec := λ sk '(c₁, c₂),
-    {code
-      ret (c₂ * (c₁ ^- sk))
-    }
+      Some (c₂ * (c₁ ^- sk))
   |}.
 
-Theorem correct_elgamal
-  : perfect (I_CORR elgamal) (CORR0 elgamal) (CORR1 elgamal).
+Theorem correct_elgamal :
+  perfect (ICORR elgamal)
+    (CORR0 elgamal) (CORR1 elgamal).
 Proof.
   eapply prove_perfect.
   apply eq_rel_perf_ind_eq.
@@ -104,7 +97,7 @@ Proof.
 Qed.
 
 Definition RED :
-  package (I_LDDH G) (I_CPA elgamal) :=
+  package (I_LDDH G) (ICPA elgamal) :=
   [package [fmap count_loc ; mpk_loc elgamal ] ;
     [ GEN ] 'tt {
       pk ← call [ GETA ] tt ;;
@@ -128,7 +121,7 @@ Notation inv0 := (
 ).
 
 Lemma PK_OTSR_RED_DDH_perfect b :
-  perfect (I_CPA elgamal) (OT_CPA elgamal b) (RED ∘ LDDH G b).
+  perfect (ICPA elgamal) (OT_CPA elgamal b) (RED ∘ LDDH G b).
 Proof.
   ssprove_share. eapply prove_perfect.
   eapply (eq_rel_perf_ind _ _ inv0).
@@ -170,10 +163,46 @@ Proof.
       by eapply r_ret.
 Qed.
 
-Theorem OT_CPA_elgamal (A : adversary (I_CPA elgamal)) :
+#[local] Open Scope sep_scope.
+#[local] Open Scope ring_scope.
+
+Lemma OT_CPA_elgamal_LDDH {A} `{Adversary (ICPA elgamal) A} :
   AdvOf (OT_CPA elgamal) A = AdvOf (LDDH G) (A ∘ RED).
 Proof. rewrite (AdvOf_perfect PK_OTSR_RED_DDH_perfect) Adv_reduction //. Qed.
 
+Notation EG_RED := (RED ∘ RDDH G).
+
+
+Lemma OT_CPA_elgamal {A}
+  `{Adversary (ICPA elgamal) A} :
+  AdvOf (OT_CPA elgamal) A =
+    AdvOf (DDH G) (A ∘ EG_RED).
+Proof. by rewrite OT_CPA_elgamal_LDDH LDDH_DDH -sep_link_assoc. Qed.
+
+
+(* One-to-Many hybrid reduction package *)
+Notation OTM P q := (SLIDE P q
+  ∘ (ID (ICPA P) || RAND (unif q))).
+
+Lemma MT_CPA_elgamal q {A}
+  `{Adversary (ICPA elgamal) A} :
+  AdvOf (MT_CPA elgamal q) A =
+    AdvOf (DDH G)
+      ((A ∘ OTM elgamal q) ∘ EG_RED) *+ q.
+Proof. by rewrite Adv_MT_CPA_OT OT_CPA_elgamal. Qed.
+
+
+(* Single-to-Multi hybrid reduction package *)
+Notation STM P n q := (HYB_MI_CPA P n q
+  ∘ (ID (ICPA P) || RAND (unif n))).
+
+Theorem MI_MT_CPA_elgamal n q {A}
+  `{Adversary (IMI_CPA elgamal n) A} :
+  AdvOf (MI_MT_CPA elgamal n q) A =
+    AdvOf (DDH G) (((A ∘ STM elgamal n q)
+      ∘ OTM elgamal q) ∘ EG_RED) *+ q *+ n.
+Proof. by rewrite Adv_MI_CPA_SI MT_CPA_elgamal. Qed.
+
 End ElGamal.
 
-Definition OT_CPA_elgamal_Z3 := OT_CPA_elgamal Z3.
+Definition OT_CPA_elgamal_Z3 := @OT_CPA_elgamal Z3.
diff --git a/theories/Crypt/examples/PKE/LDDH.v b/theories/Crypt/examples/PKE/LDDH.v
index c7ffccd..abb2154 100644
--- a/theories/Crypt/examples/PKE/LDDH.v
+++ b/theories/Crypt/examples/PKE/LDDH.v
@@ -14,7 +14,7 @@ Set Bullet Behavior "Strict Subproofs".
 Set Default Goal Selector "!".
 Set Primitive Projections.
 
-From SSProve Require Import NominalPrelude.
+From SSProve Require Import NominalPrelude Async.
 From SSProve.Crypt.examples.PKE Require Import CyclicGroup.
 
 Import PackageNotation.
@@ -28,8 +28,8 @@ Import GroupScope.
 
 #[local] Open Scope F_scope.
 
-Section LDDH.
 
+Section LDDH.
   Context (G : CyclicGroup).
 
   Definition GETA := 50%N.
@@ -66,3 +66,146 @@ Section LDDH.
     ].
 
 End LDDH.
+
+
+Section DDH.
+  Context (G : CyclicGroup).
+
+  Definition GETABC := 52%N.
+
+  Definition I_DDH :=
+    [interface
+      [ GETABC ] : { 'unit ~> 'el G × 'el G × 'el G }
+    ].
+
+  Definition DDH bit :
+    game I_DDH :=
+    [package emptym ;
+      [ GETABC ] 'tt {
+        a ← sample uniform #|exp G| ;;
+        b ← sample uniform #|exp G| ;;
+        if bit then
+          ret ('g ^ a, 'g ^ b, ('g ^ a) ^ b)
+        else
+          c ← sample uniform #|exp G| ;;
+          ret ('g ^ a, 'g ^ b, 'g ^ c)
+      }
+    ].
+End DDH.
+
+
+Section Reduction.
+  Context (G : CyclicGroup).
+
+  Definition sample_bc bit (a : 'exp G) : dist ('el G × 'el G) := {code
+    b ← sample uniform #|exp G| ;;
+    if bit then
+      ret ('g ^ b, ('g ^ a) ^ b)
+    else
+      c ← sample uniform #|exp G| ;;
+      ret ('g ^ b, 'g ^ c)
+  }.
+
+  Definition ADDH :
+    package (I_ASYNC ('exp G) ('el G × 'el G)) (I_LDDH G) :=
+    [package emptym ;
+      [ GETA ] 'tt {
+        a ← sample uniform #|exp G| ;;
+        _ ← call [ PRIME ] a ;;
+        ret ('g ^ a)
+      } ;
+      [ GETBC ] 'tt {
+        '(gb, gc) ← call [ TRIGGER ] tt ;;
+        ret (gb, gc)
+      }
+    ].
+
+  Ltac ssprove_perfect I := 
+    ssprove_share; apply prove_perfect;
+    eapply (eq_rel_perf_ind _ _ I);
+      [ ssprove_invariant; try done |].
+
+  Lemma LDDH_ADDH b : perfect (I_LDDH G) (LDDH G b) (ADDH ∘ LAZY _ _ (sample_bc b)).
+  Proof.
+    ssprove_perfect (heap_ignore [fmap mga_loc G ; lazy_loc ('exp G)]
+      ⋊ couple_cross (mga_loc G) (lazy_loc ('exp G)) (λ mga ma, mga = omap (λ a, 'g ^ a) ma)).
+    simplify_eq_rel arg.
+    - destruct arg. simpl.
+      ssprove_code_simpl.
+      ssprove_sync => a.
+      apply r_put_vs_put.
+      ssprove_restore_pre. { ssprove_invariant. }
+      by apply r_ret.
+    - destruct arg. simpl.
+      ssprove_code_simpl; simpl.
+      apply r_get_remember_lhs => mga.
+      apply r_get_remember_rhs => ma.
+      ssprove_code_simpl_more.
+      ssprove_rem_rel 0%N.
+      destruct mga, ma => //= Heq; [| apply r_fail ].
+      noconf Heq.
+      apply r_put_vs_put.
+      ssprove_sync => b'.
+      ssprove_restore_mem. { ssprove_invariant. }
+      destruct b => /=.
+      + by apply r_ret.
+      + ssprove_sync => c.
+        by apply r_ret.
+  Qed.
+
+  Definition mgbc_loc := mkloc 52%N (None : 'option ('el G × 'el G)).
+
+  Definition RDDH :
+    package (I_DDH G) (I_LDDH G) :=
+    [package [fmap mgbc_loc ];
+      [ GETA ] 'tt {
+        '(ga, gb, gc) ← call [ GETABC ] tt ;;
+        #put mgbc_loc := Some (gb, gc) ;;
+        ret ga
+      } ;
+      [ GETBC ] 'tt {
+        gbc ← getSome mgbc_loc ;;
+        #put mgbc_loc := None ;; 
+        ret gbc
+      }
+    ].
+
+  Lemma ADDH_RDDH b : perfect (I_LDDH G) (ADDH ∘ EAGER _ _ (sample_bc b)) (RDDH ∘ DDH G b).
+  Proof.
+    ssprove_perfect (heap_ignore [fmap mgbc_loc ; eager_loc ('el G × 'el G) ]
+      ⋊ couple_cross (eager_loc ('el G × 'el G)) mgbc_loc eq).
+    simplify_eq_rel arg.
+    - destruct arg. simpl.
+      ssprove_code_simpl; simpl.
+      ssprove_sync => a.
+      ssprove_sync => b'.
+      destruct b => /=.
+      + apply r_put_vs_put.
+        ssprove_restore_pre. { ssprove_invariant. }
+        by apply r_ret.
+      + ssprove_sync => c.
+        apply r_put_vs_put.
+        ssprove_restore_pre. { ssprove_invariant. }
+        by apply r_ret.
+    - destruct arg. simpl.
+      ssprove_code_simpl; simpl.
+      apply r_get_remember_lhs => lhs.
+      apply r_get_remember_rhs => mgbc.
+      ssprove_rem_rel 0%N => {lhs}->.
+      ssprove_code_simpl_more.
+      ssprove_sync => Hmgbc.
+      destruct mgbc as [ [gb gc] |] => //=.
+      apply r_put_vs_put.
+      ssprove_restore_mem. { ssprove_invariant. }
+      by apply r_ret.
+  Qed.
+
+  Lemma LDDH_DDH {A} {VA : ValidPackage (loc A) (I_LDDH G) A_export A} :
+    AdvOf (LDDH G) A = AdvOf (DDH G) (A ∘ RDDH).
+  Proof.
+    rewrite (AdvOf_perfect LDDH_ADDH).
+    rewrite Adv_reduction -(Adv_perfect_l (ASYNC_perfect _ _ _ _)).
+    rewrite -(Adv_perfect_r (ASYNC_perfect _ _ _ _)).
+    by rewrite -Adv_reduction (AdvOf_perfect ADDH_RDDH) Adv_reduction.
+  Qed.
+End Reduction.
diff --git a/theories/Crypt/examples/PKE/MultiInstance.v b/theories/Crypt/examples/PKE/MultiInstance.v
new file mode 100644
index 0000000..fd4de8d
--- /dev/null
+++ b/theories/Crypt/examples/PKE/MultiInstance.v
@@ -0,0 +1,364 @@
+Set Warnings "-notation-overridden,-ambiguous-paths".
+From mathcomp Require Import all_ssreflect all_algebra reals distr realsum
+  fingroup.fingroup solvable.cyclic prime ssrnat ssreflect ssrfun ssrbool ssrnum
+  eqtype choice seq.
+Set Warnings "notation-overridden,ambiguous-paths".
+
+From Coq Require Import Utf8 Lia.
+From extructures Require Import ord fset fmap.
+
+From Equations Require Import Equations.
+Require Equations.Prop.DepElim.
+Set Equations With UIP.
+
+Set Bullet Behavior "Strict Subproofs".
+Set Default Goal Selector "!".
+Set Primitive Projections.
+
+From SSProve.Crypt Require Import NominalPrelude
+  TotalProbability HybridArgument.
+Import PackageNotation.
+#[local] Open Scope package_scope.
+
+From SSProve.Crypt.examples.PKE Require Import Scheme.
+Import PKE.
+
+
+Notation "x ← 'get' n [ i ] ;; c" :=
+    ( y ← get n ;;
+      #assert isSome (y i) as Hi ;;
+      let x := getSome (y i) Hi in c )
+    (at level 100, n at next level, right associativity,
+    format "x  ←  get  n  [  i  ]  ;;  '//' c")
+    : package_scope.
+
+Notation "'#put' n [ i ] ':=' u ;; c" :=
+    ( y ← get n ;; #put n := setm y i u ;; c )
+    (at level 100, u at next level, right associativity,
+    format "#put  n  [  i  ]  :=  u  ;;  '//' c")
+    : package_scope.
+
+
+Section MultiInstanceDef.
+
+(* Multi-CPA *)
+Definition IMI_CPA P n := [interface
+  [ GEN ] : { 'fin n ~> P.(Pub) } ;
+  [ QUERY ] : { 'fin n × P.(Mes) ~> P.(Cip) }
+].
+
+Definition pks_loc P := mkloc 51 (emptym : chMap nat P.(Pub)).
+
+Definition MI_CPA P n b :
+  game (IMI_CPA P n) :=
+  [package [fmap pks_loc P ] ;
+    [ GEN ] : { 'fin n ~> P.(Pub) } (j) {
+      '(_, pk) ← P.(keygen) ;;
+      #put pks_loc P [ j ] := pk ;;
+      ret pk
+    } ;
+    [ QUERY ] : { 'fin n × P.(Mes) ~> P.(Cip) } '(j, m) {
+      pk ← get pks_loc P [ j ] ;;
+      if b then
+        P.(enc) pk m
+      else
+        P.(sample_Cip)
+    }
+  ].
+
+Definition counts_loc := mkloc 52 (emptym : chMap nat nat).
+
+Definition MI_COUNT P n q :
+  package (IMI_CPA P n) (IMI_CPA P n) :=
+  [package [fmap counts_loc ] ;
+    [ GEN ] : { 'fin n ~> P.(Pub) } (j) {
+      call [ GEN ] : { 'fin n ~> P.(Pub) } j
+    } ;
+    [ QUERY ] : { 'fin n × P.(Mes) ~> P.(Cip) } '(j, m) {
+      counts ← get counts_loc ;;
+      let countj := odflt 0 (counts j) in
+      #assert countj < q ;;
+      c ← call [ QUERY ] : { 'fin n × P.(Mes) ~> P.(Cip) } (j, m) ;;
+      #put counts_loc :=
+        setm counts j countj.+1 ;;
+      ret c
+    }
+  ].
+
+End MultiInstanceDef.
+
+#[local] Open Scope sep_scope.
+
+Notation MI_MT_CPA P n q :=
+  (λ b, MI_COUNT P n q ∘ MI_CPA P n b).
+
+Section MultiInstance.
+
+Definition HYB_MI_CPA P n q :
+  package (unionm (ICPA P) (IPICK nat))
+    (IMI_CPA P n) :=
+  [package [fmap pks_loc P ; counts_loc ] ;
+    [ GEN ] : { 'fin n ~> P.(Pub) } (j) {
+      i ← call [ PICK ] : { unit ~> nat } tt ;;
+      pk ← (
+        if i == j then
+          call [ GEN ] tt
+        else
+          '(_, pk) ← P.(keygen) ;;
+          ret pk
+      ) ;;
+      #put pks_loc P [ j ] := pk ;;
+      ret pk
+    } ;
+    [ QUERY ] : { 'fin n × P.(Mes) ~> P.(Cip) } '(j, m) {
+      counts ← get counts_loc ;;
+      let countj := odflt 0 (counts j) in
+      #assert countj < q ;;
+      pk ← get pks_loc P [ j ] ;;
+      i ← call [ PICK ] : { unit ~> nat } tt ;;
+      c ← (
+        if j < i then
+          c ← P.(sample_Cip) ;; ret c
+        else if i < j then
+          c ← P.(enc) pk m ;; ret c
+        else
+          call [ QUERY ] m
+      ) ;;
+      #put counts_loc :=
+        setm counts j countj.+1 ;;
+      ret c
+    }
+  ].
+
+Lemma rsame_head_scheme {A B}
+  {m : raw_code A} {f₀ f₁ : A → raw_code B}
+  {pre : precond} {post : postcond B B}
+  `{Vm : ValidCode emptym [interface] A m} :
+  (∀ a : A, ⊢ ⦃ pre ⦄ f₀ a ≈ f₁ a ⦃ post ⦄)
+  → ⊢ ⦃ pre ⦄ x ← m ;; f₀ x ≈ x ← m ;; f₁ x ⦃ post ⦄.
+Proof.
+  intros. eapply rsame_head_alt; [ exact _ | .. | done ].
+  1,2: intros; exfalso; eapply fhas_empty; eassumption.
+Qed.
+
+Notation inv P q := (
+  heap_ignore ([fmap mpk_loc P ; count_loc ])
+  ⋊ couple_rhs (pks_loc P) (mpk_loc P) (λ pks mpk, pks q = mpk)
+  ⋊ couple_rhs counts_loc count_loc (λ cs c, odflt 0 (cs q) = c)
+).
+
+Ltac ssprove_ret :=
+  ssprove_restore_mem; [ ssprove_invariant; try done | by apply r_ret ].
+
+Hint Extern 50 (_ = code_link _ _) =>
+  rewrite code_link_scheme : ssprove_code_simpl.
+
+Lemma MI_CPA_0_n P n q b :
+  perfect (IMI_CPA P n) (MI_MT_CPA P n q b)
+    (HYB_MI_CPA P n q ∘ (MT_CPA P q true ||
+       CONST (if b then 0 else n))).
+Proof.
+  ssprove_share. eapply prove_perfect.
+  apply (eq_rel_perf_ind _ _ (inv P (if b then 0 else n))).
+  { by ssprove_invariant. }
+  simplify_eq_rel arg.
+  - ssprove_code_simpl.
+    destruct ((if b then 0 else n) == arg)%B eqn:E.
+    + rewrite E /=.
+      ssprove_code_simpl.
+      apply rsame_head_scheme => [[sk pk]].
+      ssprove_swap_rhs 0.
+      apply r_get_vs_get_remember => [pks].
+      apply r_put_rhs, r_put_vs_put.
+      ssprove_ret.
+      move: E => /eqP -> H'.
+      by rewrite setmE eq_refl.
+    + rewrite E /=.
+      ssprove_code_simpl.
+      apply rsame_head_scheme => [[sk pk]].
+      apply r_get_vs_get_remember => [pks].
+      apply r_put_vs_put.
+      ssprove_ret.
+      by rewrite setmE E.
+  - destruct arg as [j m]. simpl.
+    ssprove_code_simpl.
+    apply r_get_vs_get_remember => [counts].
+    ssprove_sync => Hcnt.
+    destruct b; [ destruct (0 < j) eqn:E |]; simpl.
+    + ssprove_code_simpl.
+      apply r_get_vs_get_remember => [pks].
+      ssprove_code_simpl_more.
+      ssprove_sync => Hpks.
+      apply rsame_head_scheme => [pk].
+      apply r_put_vs_put.
+      ssprove_ret.
+      by rewrite setmE -(negbK (0%N == j)%B) eq_sym -lt0n E.
+    + simpl in *. ssprove_code_simpl.
+      apply r_get_vs_get_remember => [pks].
+      ssprove_code_simpl_more.
+      ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      ssprove_sync => Hpks.
+      ssprove_swap_seq_rhs [:: 2; 3; 1 ]%N.
+      apply r_get_remember_rhs => [c].
+      apply r_get_remember_rhs => [mpk].
+      ssprove_rem_rel 1%N => ?.
+      ssprove_rem_rel 0%N => ?; subst.
+      rewrite lt0n in E.
+      move: E => /eqP E. subst.
+      rewrite {}E {j} in Hcnt, Hpks |- *.
+      rewrite Hcnt /=.
+      destruct (pks 0) eqn:E'.
+      2: assert (Hpks' := Hpks).
+      2: by rewrite E' in Hpks'.
+      move: Hpks. rewrite E' /= => _.
+      apply r_put_rhs.
+      apply rsame_head_scheme => [c].
+      apply r_put_vs_put.
+      ssprove_ret.
+      by rewrite setmE eq_refl.
+    + rewrite ltn_ord.
+      ssprove_sync => pks.
+      ssprove_code_simpl_more.
+      ssprove_sync => Hpks.
+      ssprove_code_simpl.
+      apply rsame_head_scheme => [c].
+      apply r_put_vs_put.
+      ssprove_ret.
+      by rewrite setmE -(negbK (n == j)%B) neq_ltn ltn_ord orbC.
+Qed.
+
+Notation inv' P i := (
+  heap_ignore ([fmap mpk_loc P ; count_loc ])
+  ⋊ couple_lhs (pks_loc P) (mpk_loc P) (λ pks mpk, pks i%N = mpk)
+  ⋊ couple_lhs counts_loc count_loc (λ cs c, odflt 0 (cs i%N) = c)
+  ⋊ couple_rhs (pks_loc P) (mpk_loc P) (λ pks mpk, pks i.+1%N = mpk)
+  ⋊ couple_rhs counts_loc count_loc (λ cs c, odflt 0 (cs i.+1%N) = c)
+).
+
+Lemma eq_succ (k : nat) : (k.+1 == k)%B = false.
+Proof. rewrite gtn_eqF //. Qed.
+
+Lemma MI_CPA_i P n q i :
+  perfect (IMI_CPA P n)
+    (HYB_MI_CPA P n q ∘
+      (MT_CPA P q false || CONST i   ))
+    (HYB_MI_CPA P n q ∘
+      (MT_CPA P q true  || CONST i.+1)).
+Proof.
+  ssprove_share. eapply prove_perfect.
+  apply (eq_rel_perf_ind _ _ (inv' P i)).
+  { by ssprove_invariant. }
+  simplify_eq_rel arg.
+  - ssprove_code_simpl.
+    destruct (i == arg)%B eqn:E; [| destruct (i.+1 == arg)%B eqn:E' ].
+    + rewrite E /=.
+      ssprove_code_simpl.
+      move: E => /eqP {i}->.
+      rewrite gtn_eqF //=.
+      apply rsame_head_scheme => [[sk pk]].
+      ssprove_swap_lhs 0%N.
+      ssprove_code_simpl.
+      apply r_get_vs_get_remember => pks.
+      apply r_put_lhs, r_put_vs_put.
+      ssprove_ret.
+      * by rewrite setmE eq_refl.
+      * by rewrite setmE eq_succ.
+    + rewrite E E' /=.
+      ssprove_code_simpl.
+      apply rsame_head_scheme => [[sk pk]].
+      ssprove_swap_rhs 0%N.
+      apply r_get_vs_get_remember => pks.
+      apply r_put_rhs, r_put_vs_put.
+      ssprove_ret.
+      * by rewrite setmE E.
+      * by rewrite setmE E'.
+    + rewrite E E' /=.
+      ssprove_code_simpl.
+      apply rsame_head_scheme => [[sk pk]].
+      apply r_get_vs_get_remember => pks.
+      apply r_put_vs_put.
+      ssprove_ret.
+      * by rewrite setmE E.
+      * by rewrite setmE E'.
+  - destruct arg as [j m] => /=.
+    ssprove_code_simpl.
+    apply r_get_vs_get_remember => counts.
+    ssprove_sync => Hcnt.
+    destruct j as [j Hj].
+    simpl in *.
+    hybrid_cases j i.
+    + ssprove_sync => pks.
+      ssprove_sync => Hpks.
+      apply rsame_head_scheme => [c].
+      apply r_put_vs_put.
+      ssprove_ret.
+      * rewrite setmE -(negbK (i == j)%B) neq_ltn. by replace_many.
+      * rewrite setmE -(negbK (i.+1 == j)%B) neq_ltn. by replace_many.
+    + ssprove_code_simpl_more.
+      ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      ssprove_swap_seq_lhs [:: 4; 5 ]%N.
+      apply r_get_vs_get_remember => pks.
+      ssprove_sync => Hpks.
+      apply r_get_remember_lhs => c.
+      ssprove_rem_rel 2%N => <-. rewrite Hcnt.
+      apply r_get_remember_lhs => pk.
+      ssprove_rem_rel 3%N => Hpk. rewrite -Hpk Hpks /=.
+      apply r_put_lhs, rsame_head_scheme => [cip].
+      apply r_put_vs_put.
+      ssprove_ret.
+      * by rewrite setmE eq_refl.
+      * by rewrite setmE eq_succ.
+    + ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      ssprove_swap_seq_rhs [:: 4; 5 ]%N.
+      apply r_get_vs_get_remember => pks.
+      ssprove_sync => Hpks.
+      apply r_get_remember_rhs => c.
+      ssprove_rem_rel 0%N => <-. rewrite Hcnt.
+      apply r_get_remember_rhs => pk.
+      ssprove_rem_rel 1%N => Hpk. rewrite -Hpk /=.
+      destruct (pks i.+1) as [ pk' |] eqn:E.
+      2: assert (Hpks' := Hpks).
+      2: by rewrite E in Hpks'.
+      move: Hpks. rewrite E /= => _.
+      apply r_put_rhs, rsame_head_scheme => [cip].
+      apply r_put_vs_put.
+      ssprove_ret.
+      * by rewrite setmE eq_sym eq_succ.
+      * by rewrite setmE eq_refl.
+    + ssprove_sync => pks.
+      ssprove_sync => Hpks.
+      apply rsame_head_scheme => [c].
+      apply r_put_vs_put.
+      ssprove_ret.
+      * rewrite setmE -(negbK (i == j)%B) neq_ltn.
+        by replace_many.
+      * rewrite setmE -(negbK (i.+1 == j)%B) neq_ltn.
+        by replace_many.
+Qed.
+
+#[local] Open Scope ring_scope.
+#[local] Open Scope sep_scope.
+
+(* Single-to-Multiple hybrid reduction package *)
+Notation STM P n q := (HYB_MI_CPA P n q ∘
+  (ID (ICPA P) || RAND (unif n))).
+
+Theorem Adv_MI_CPA_SI P n q A
+  `{Adversary (IMI_CPA P n) A} :
+  AdvOf (MI_MT_CPA P n q) A =
+    AdvOf (MT_CPA P q) (A ∘ STM P n q) *+ n.
+Proof.
+  eapply @Adv_hybrid.
+  1-4: intros; ssprove_valid.
+  1-2: apply MI_CPA_0_n.
+  intros i _; apply MI_CPA_i.
+Qed.
+
+End MultiInstance.
diff --git a/theories/Crypt/examples/PKE/OneToMany.v b/theories/Crypt/examples/PKE/OneToMany.v
new file mode 100644
index 0000000..9198b76
--- /dev/null
+++ b/theories/Crypt/examples/PKE/OneToMany.v
@@ -0,0 +1,259 @@
+Set Warnings "-notation-overridden,-ambiguous-paths".
+From mathcomp Require Import all_ssreflect all_algebra reals distr realsum
+  fingroup.fingroup solvable.cyclic prime ssrnat ssreflect ssrfun ssrbool ssrnum
+  eqtype choice seq.
+Set Warnings "notation-overridden,ambiguous-paths".
+
+From Coq Require Import Utf8 Lia.
+From extructures Require Import ord fset fmap.
+
+From Equations Require Import Equations.
+Require Equations.Prop.DepElim.
+Set Equations With UIP.
+
+Set Bullet Behavior "Strict Subproofs".
+Set Default Goal Selector "!".
+Set Primitive Projections.
+
+From SSProve.Crypt Require Import NominalPrelude
+  TotalProbability HybridArgument.
+Import PackageNotation.
+#[local] Open Scope package_scope.
+
+From SSProve.Crypt.examples.PKE Require Import Scheme CyclicGroup LDDH.
+
+Import PKE GroupScope.
+#[local] Open Scope nat_scope.
+#[local] Open Scope F_scope.
+
+Section OneToMany.
+
+Definition mpk_loc' P := mkloc 45 (None : option P.(Pub)).
+Definition count_loc' := mkloc 46 (0 : nat).
+
+Definition SLIDE P q : package
+    (unionm (ICPA P) (IPICK nat)) (ICPA P) :=
+  [package [fmap count_loc' ; mpk_loc' P ] ;
+    [ GEN ] : { 'unit ~> P.(Pub) } 'tt {
+      pk ← call [ GEN ] tt ;;
+      #put mpk_loc' P := Some pk ;;
+      ret pk
+    } ;
+    [ QUERY ] : { P.(Mes) ~> P.(Cip) } (m) {
+      count ← get count_loc' ;;
+      #assert (count < q) ;;
+      #put count_loc' := count.+1 ;;
+      i ← call [ PICK ] tt ;;
+      pk ← getSome mpk_loc' P ;;
+      if (count < i) then
+        c ← P.(sample_Cip) ;; ret c
+      else if (i < count) then
+        c ← P.(enc) pk m ;; ret c
+      else
+        call [ QUERY ] m
+    }
+  ].
+
+Definition R (i : 'nat) (c : 'nat) (c' : 'nat)
+  := c = (c' > i)%N.
+
+Notation inv P i := (
+  heap_ignore ([fmap mpk_loc' P ; count_loc ; count_loc' ])
+  ⋊ couple_cross (mpk_loc P) (mpk_loc' P) eq
+  ⋊ couple_cross count_loc count_loc' eq
+  ⋊ couple_rhs count_loc count_loc' (R i)
+).
+
+Lemma rsame_head_scheme {A B}
+  {m : raw_code A} {f₀ f₁ : A → raw_code B}
+  {pre : precond} {post : postcond B B}
+  `{Vm : ValidCode emptym [interface] A m} :
+  (∀ a : A, ⊢ ⦃ pre ⦄ f₀ a ≈ f₁ a ⦃ post ⦄)
+  → ⊢ ⦃ pre ⦄ x ← m ;; f₀ x ≈ x ← m ;; f₁ x ⦃ post ⦄.
+Proof.
+  intros. eapply rsame_head_alt; [ exact _ | .. | done ].
+  1,2: intros; exfalso; eapply fhas_empty; eassumption.
+Qed.
+
+Lemma MT_CPA_SLIDE_perfect {P q} b :
+  perfect (ICPA P) (MT_CPA P q b) (SLIDE P q
+    ∘ (OT_CPA P true ||
+       CONST (if b then 0 else q))).
+Proof.
+  ssprove_share.
+  eapply prove_perfect.
+  apply (eq_rel_perf_ind _ _ (inv P (if b then 0 else q))).
+  { by ssprove_invariant. }
+  simplify_eq_rel m.
+  - destruct m; simpl.
+    simplify_linking.
+    ssprove_code_simpl.
+    apply rsame_head_scheme => [[_ pk]].
+    apply r_put_vs_put.
+    apply r_put_rhs.
+    ssprove_restore_pre.
+    2: by apply r_ret.
+    ssprove_invariant.
+
+  - ssprove_code_simpl; simpl.
+    ssprove_code_simpl_more.
+    apply r_get_remember_lhs => c.
+    apply r_get_remember_rhs => cr.
+    ssprove_rem_rel 1%N => {cr}<-.
+    ssprove_sync => H.
+    ssprove_swap_lhs 0%N; ssprove_swap_rhs 0%N.
+    apply r_get_remember_lhs => mpk.
+    apply r_get_remember_rhs => mpk'.
+    ssprove_rem_rel 2%N => {mpk'}<-.
+    ssprove_swap_lhs 0%N; ssprove_swap_rhs 0%N.
+    ssprove_sync => H'.
+    destruct mpk as [pk|] => //= {H'}.
+    destruct b; [ destruct c | ]; simpl.
+    + ssprove_code_simpl_more.
+      ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      ssprove_swap_rhs 0%N.
+      apply r_get_remember_rhs => cr.
+      ssprove_rem_rel 0%N.
+      unfold R; simpl; move=> -> {cr} //=.
+
+      ssprove_swap_seq_rhs [:: 1%N ; 0%N ].
+      eapply @r_get_remind_rhs.
+      1: eapply Remembers_syncs; exact _. (* !! *)
+      apply r_put_rhs.
+      apply r_put_vs_put => //=.
+      eapply rsame_head_scheme => x.
+      ssprove_restore_mem.
+      { ssprove_invariant. }
+      by apply r_ret.
+
+    + apply r_put_vs_put.
+      rewrite code_link_scheme. (* !! *)
+      apply rsame_head_scheme => x.
+      ssprove_restore_mem.
+      2: by apply r_ret.
+      ssprove_invariant.
+    + rewrite H.
+      apply r_put_vs_put.
+      rewrite code_link_scheme.
+      apply rsame_head_scheme => x.
+      ssprove_restore_mem.
+      2: by apply r_ret.
+      ssprove_invariant.
+      rewrite /R 2!ltnNge H (ltnW H) //.
+Qed.
+
+Notation inv' P i := (
+  heap_ignore [fmap count_loc ]
+  ⋊ couple_lhs (mpk_loc P) (mpk_loc' P) eq
+  ⋊ couple_rhs (mpk_loc P) (mpk_loc' P) eq
+  ⋊ couple_lhs count_loc count_loc' (R i%N)
+  ⋊ couple_rhs count_loc count_loc' (R i.+1)
+).
+
+Lemma SLIDE_succ_perfect {P q i} :
+  perfect (ICPA P)
+    (SLIDE P q ∘
+      (OT_CPA P false || CONST i   ))
+    (SLIDE P q ∘
+      (OT_CPA P true  || CONST i.+1)).
+Proof.
+  ssprove_share.
+  eapply prove_perfect.
+  apply (eq_rel_perf_ind _ _ (inv' P i)).
+  { by ssprove_invariant. }
+  simplify_eq_rel m.
+  - destruct m; simpl.
+    simplify_linking.
+    ssprove_code_simpl.
+    eapply rsame_head_alt.
+    1-3: try apply prog_valid; intros; exfalso; eapply fhas_empty; eassumption.
+    move=> [_ pk].
+    apply r_put_vs_put.
+    apply r_put_vs_put.
+    ssprove_restore_pre.
+    2: by apply r_ret.
+    by ssprove_invariant.
+
+  - ssprove_code_simpl.
+    rewrite 2!code_link_scheme.
+    apply r_get_vs_get_remember.
+    intros c.
+    ssprove_code_simpl.
+    ssprove_sync => /ltP H.
+    ssprove_swap_lhs 0%N; ssprove_swap_rhs 0%N.
+    apply r_get_vs_get_remember.
+    1: ssprove_invariant.
+    intros mpk.
+    ssprove_swap_lhs 0%N; ssprove_swap_rhs 0%N.
+    ssprove_sync => H'.
+    hybrid_cases c i.
+    + apply r_put_vs_put.
+      apply rsame_head_scheme => x.
+      ssprove_restore_mem.
+      { ssprove_invariant; unfold R; by replace_many. }
+      by apply r_ret.
+    + ssprove_code_simpl.
+      ssprove_swap_lhs 0%N.
+      apply r_get_remember_lhs => c'.
+      ssprove_rem_rel 1%N.
+      rewrite //= /R ltnn => -> {c'}.
+      ssprove_code_simpl_more.
+      ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      ssprove_swap_seq_lhs [:: 1%N ; 0%N ].
+      apply r_get_remember_lhs => mpk'.
+      ssprove_rem_rel 3%N => {mpk'}->.
+      apply r_put_vs_put.
+      apply r_put_lhs.
+      rewrite H' //=.
+      apply rsame_head_scheme => x.
+      ssprove_restore_mem.
+      { ssprove_invariant; by replace_many. }
+      by apply r_ret.
+    + ssprove_code_simpl.
+      ssprove_swap_rhs 0%N.
+      apply r_get_remember_rhs => c'.
+      ssprove_rem_rel 0%N.
+      rewrite //= /R ltnn => -> {c'}.
+      ssprove_code_simpl_more.
+      ssprove_code_simpl.
+      ssprove_code_simpl_more.
+      destruct mpk as [pk|] => //=.
+      ssprove_swap_seq_rhs [:: 1%N ; 0%N ].
+      apply r_get_remember_rhs => mpk'.
+      ssprove_rem_rel 2%N => -> //= {mpk'}.
+      apply r_put_vs_put.
+      apply r_put_rhs.
+      rewrite code_link_scheme.
+      eapply rsame_head_scheme => x.
+      ssprove_restore_mem.
+      2: by apply r_ret.
+      ssprove_invariant; by replace_many.
+    + apply r_put_vs_put.
+      rewrite 2!code_link_scheme.
+      apply rsame_head_scheme => c'.
+      ssprove_restore_mem.
+      2: by apply r_ret.
+      ssprove_invariant; unfold R; by replace_many.
+Qed.
+
+#[local] Open Scope ring_scope.
+#[local] Open Scope sep_scope.
+
+(* One-to-Many hybrid reduction package *)
+Notation OTM P q := (SLIDE P q ∘
+  (ID (ICPA P) || RAND (unif q))).
+
+Theorem Adv_MT_CPA_OT P q A
+  `{Adversary (ICPA P) A} :
+  AdvOf (MT_CPA P q) A =
+    AdvOf (OT_CPA P) (A ∘ OTM P q) *+ q.
+Proof.
+  eapply @Adv_hybrid.
+  1-4: intros; ssprove_valid.
+  1-2: apply: MT_CPA_SLIDE_perfect.
+  intros i _; apply: SLIDE_succ_perfect.
+Qed.
+
+End OneToMany.
diff --git a/theories/Crypt/examples/PKE/Scheme.v b/theories/Crypt/examples/PKE/Scheme.v
index 0f14bf3..98229f3 100644
--- a/theories/Crypt/examples/PKE/Scheme.v
+++ b/theories/Crypt/examples/PKE/Scheme.v
@@ -15,8 +15,10 @@ Set Primitive Projections.
 
 From SSProve Require Import NominalPrelude.
 
+#[local] Open Scope nat.
 Import PackageNotation.
 #[local] Open Scope package_scope.
+#[local] Open Scope sep_scope.
 
 
 Module PKE.
@@ -26,66 +28,59 @@ Record scheme :=
   ; Pub : choice_type
   ; Mes : choice_type
   ; Cip : choice_type
-  ; sample_Cip :
-      code emptym [interface] Cip
-  ; keygen :
-      code emptym [interface] (Sec × Pub)
-  ; enc : ∀ (k : Pub) (m : Mes),
-      code emptym [interface] Cip
-  ; dec : ∀ (k : Sec) (c : Cip),
-      code emptym [interface] Mes
+  ; sample_Cip : dist Cip
+  ; keygen : dist (Sec × Pub)
+  ; enc : Pub → Mes → dist Cip
+  ; dec : Sec → Cip → option Mes
   }.
 
 Section Defs.
-  Context (P : scheme).
+  Definition ENCDEC := 0.
 
-  Definition ENCDEC := 0%N.
+  Definition ICORR P :=
+    [interface [ ENCDEC ] : { P.(Mes) ~> option P.(Mes) } ].
 
-  Definition I_CORR :=
-    [interface [ ENCDEC ] : { P.(Mes) ~> P.(Mes) } ].
-
-  Definition CORR0 :
-    game I_CORR :=
+  Definition CORR0 P :
+    game (ICORR P) :=
     [package emptym ;
-      [ ENCDEC ] : { P.(Mes) ~> P.(Mes) } (m) {
+      [ ENCDEC ] : { P.(Mes) ~> option P.(Mes) } (m) {
         '(sk, pk) ← P.(keygen) ;;
         c ← P.(enc) pk m ;;
-        m' ← P.(dec) sk c ;;
-        ret m'
+        ret (P.(dec) sk c)
       }
     ].
 
-  Definition CORR1 :
-    game I_CORR :=
+  Definition CORR1 P :
+    game (ICORR P) :=
     [package emptym ;
-      [ ENCDEC ] : { P.(Mes) ~> P.(Mes) } (m) {
-        ret m
+      [ ENCDEC ] : { P.(Mes) ~> option P.(Mes) } (m) {
+        ret (Some m)
       }
     ].
 
   Definition CORR b := if b then CORR0 else CORR1.
 
 
-  Definition mpk_loc := mkloc 1 (None : option P.(Pub)).
-  Definition GEN := 0%N.
-  Definition QUERY := 1%N.
+  Definition mpk_loc P := mkloc 1 (None : option P.(Pub)).
+  Definition GEN := 0.
+  Definition QUERY := 1.
 
-  Definition I_CPA :=
+  Definition ICPA P :=
     [interface
-      [ GEN ] : { 'unit ~> P.(Pub) } ;
+      [ GEN ] : { unit ~> P.(Pub) } ;
       [ QUERY ] : { P.(Mes) ~> P.(Cip) }
     ].
 
-  Definition CPA b :
-    game I_CPA :=
-    [package [fmap mpk_loc ] ;
-      [ GEN ] : { 'unit ~> P.(Pub) } 'tt {
+  Definition CPA P b :
+    game (ICPA P) :=
+    [package [fmap mpk_loc P ] ;
+      [ GEN ] : { unit ~> P.(Pub) } 'tt {
         '(_, pk) ← P.(keygen) ;;
-        #put mpk_loc := Some pk ;;
+        #put mpk_loc P := Some pk ;;
         ret pk
       } ;
       [ QUERY ] : { P.(Mes) ~> P.(Cip) } (m) {
-        pk ← getSome mpk_loc ;;
+        pk ← getSome mpk_loc P ;;
         if b then
           P.(enc) pk m
         else
@@ -95,24 +90,24 @@ Section Defs.
 
   Definition count_loc := mkloc 142 (0 : 'nat).
 
-  Definition COUNT n :
-    package (I_CPA) (I_CPA) :=
+  Definition COUNT P q :
+    package (ICPA P) (ICPA P) :=
     [package [fmap count_loc ] ;
-      [ GEN ] : { 'unit ~> P.(Pub) } 'tt {
-        pk ← call [ GEN ] : { 'unit ~> P.(Pub) } tt ;;
-        ret pk
+      [ GEN ] : { unit ~> P.(Pub) } (_) {
+        call [ GEN ] : { unit ~> P.(Pub) } tt
       } ;
       [ QUERY ] : { P.(Mes) ~> P.(Cip) } (m) {
         count ← get count_loc ;; 
-        #assert (count < n)%N ;;
+        #assert count < q ;;
         #put count_loc := count.+1 ;;
-        c ← call [ QUERY ] : { P.(Mes) ~> P.(Cip) } m ;;
-        ret c
+        call [ QUERY ] : { P.(Mes) ~> P.(Cip) } m
       }
     ].
 End Defs.
 
-Notation MT_CPA P n := (λ b, COUNT P n ∘ CPA P b)%sep.
-Notation OT_CPA P := (λ b, COUNT P 1 ∘ CPA P b)%sep.
+Notation MT_CPA P q :=
+  (λ b, COUNT P q ∘ CPA P b).
+Notation OT_CPA P := 
+  (λ b, COUNT P 1 ∘ CPA P b).
 
 End PKE.
diff --git a/theories/Crypt/examples/PRFMAC.v b/theories/Crypt/examples/PRFMAC.v
index c01466a..074795a 100644
--- a/theories/Crypt/examples/PRFMAC.v
+++ b/theories/Crypt/examples/PRFMAC.v
@@ -389,16 +389,13 @@ Proof.
       ssprove_invariant=> h m' k'.
       rewrite domm_set in_fsetU in_fset1 setmE.
       case: (eq_dec (m', k') (m, k)) => Heq.
-      1: {
-        case: Heq => [-> ->].
-        by rewrite !eq_refl /= eq_refl.
-      }
+      { noconf Heq. by rewrite !eq_refl. }
       move /eqP /negPf in Heq.
       rewrite Heq /=.
       rewrite xpair_eqE in Heq.
       case: (eq_dec m' m) => Heqm.
       * rewrite Heqm eq_refl /= in Heq*.
-        by rewrite Heq Hinv Heqt.
+        by rewrite Hinv Heqt.
       * move /eqP /negPf in Heqm.
         by rewrite Heqm Hinv.
   - ssprove_code_simpl.
diff --git a/theories/Crypt/examples/PRFPRG.v b/theories/Crypt/examples/PRFPRG.v
index d5bd681..538cbdd 100644
--- a/theories/Crypt/examples/PRFPRG.v
+++ b/theories/Crypt/examples/PRFPRG.v
@@ -250,7 +250,7 @@ Proof.
     ssprove_restore_mem;
       last by apply: r_ret.
     ssprove_invariant.
-    by rewrite -?subnE subSnn.
+    by rewrite ltnn.
   - move /eqP /negPf in Heq.
     rewrite Heq /=.
     destruct (count < i) eqn:Hlt.
@@ -260,8 +260,6 @@ Proof.
     all: ssprove_restore_mem;
       last by apply: r_ret.
     all: ssprove_invariant.
-    + rewrite eqnE 2!subn_eq0 ltnW //. auto.
-    + rewrite eqnE 2!subn_eq0 Hlt //.
 Qed.
 
 (**
@@ -296,7 +294,7 @@ Proof.
     ssprove_restore_mem;
       last by apply: r_ret.
     ssprove_invariant.
-    by rewrite -?subnE subSnn.
+    by rewrite ltnn.
   - move /eqP /negPf in Heq.
     rewrite Heq /=.
     destruct (count < i) eqn:Hlt.
@@ -308,8 +306,6 @@ Proof.
     all: ssprove_restore_mem;
       last by apply: r_ret.
     all: ssprove_invariant.
-    + rewrite eqnE 2!subn_eq0 ltnW //. auto.
-    + rewrite eqnE 2!subn_eq0 Hlt //.
 Qed.
 
 Local Open Scope ring_scope.
diff --git a/theories/Crypt/nominal/Adv.v b/theories/Crypt/nominal/Adv.v
index 0104007..c7839b3 100644
--- a/theories/Crypt/nominal/Adv.v
+++ b/theories/Crypt/nominal/Adv.v
@@ -38,7 +38,11 @@ Import PackageNotation.
 Definition Pr' (P : nom_package) := Pr (val P).
 
 Definition Adv (G G' A : nom_package) : R
-  := `| Pr' (A ∘ G)%sep true - Pr' (A ∘ G')%sep true |.
+  := locked `| Pr' (A ∘ G)%sep true - Pr' (A ∘ G')%sep true |.
+
+Lemma AdvE G G' A
+  : Adv G G' A = `| Pr' (A ∘ G)%sep true - Pr' (A ∘ G')%sep true |.
+Proof. by rewrite /Adv -lock. Qed.
 
 Add Parametric Morphism : val with
   signature alpha ==> alpha as val_mor.
@@ -54,13 +58,13 @@ Proof. intros ? ? E1 ? ? E2 ? ? E3. by rewrite /Adv E1 E2 E3. Qed.
 
 Lemma Adv_triangle {G1 G2 G3 : nom_package} A
   : Adv G1 G3 A <= Adv G1 G2 A + Adv G2 G3 A.
-Proof. apply Advantage_triangle. Qed.
+Proof. rewrite /Adv 3!sep_linkE -3!lock. apply Advantage_triangle. Qed.
 
 Lemma Adv_same (G A : nom_package) : Adv G G A = 0.
-Proof. rewrite /Adv addrN. rewrite normr0 //. Qed.
+Proof. rewrite AdvE addrN. rewrite normr0 //. Qed.
 
 Lemma Adv_sym (G G' A : nom_package) : Adv G G' A = Adv G' G A.
-Proof. apply: distrC. Qed.
+Proof. rewrite 2!AdvE. apply: distrC. Qed.
 
 Lemma Adv_alpha (G G' A : nom_package)
   : G ≡ G' → Adv G G' A = 0.
@@ -85,8 +89,8 @@ Lemma Adv_AdvantageE (G G' A : nom_package) :
   Adv G G' A = AdvantageE G G' A.
 Proof.
   intros D1 D2.
-  unfold Adv, AdvantageE.
-  rewrite link_sep_link ?link_sep_link //.
+  rewrite AdvE /AdvantageE.
+  by rewrite link_sep_link ?link_sep_link.
 Qed.
 
 Lemma supp_prod {X Y : nomType} (x : X) (y : Y)
@@ -200,6 +204,10 @@ Lemma perfect_trans {I G G' G''}
   : perfect I G G' → perfect I G' G'' → perfect I G G''.
 Proof. intros H1 H2 A VA. rewrite (Adv_perfect_l H1) H2 //. Qed.
 
+Lemma perfect_Pr {I} {G G' A : nom_package} `{ValidPackage (loc A) I A_export A} :
+  perfect I G G' → Pr' (A ∘ G)%sep true = Pr' (A ∘ G')%sep true.
+Proof. intros Hperf. apply subr0_eq, normr0_eq0. by rewrite -Hperf /Adv -lock. Qed.
+
 Lemma prove_perfect {E} {G G' : nom_package}
   `{V  : ValidPackage (loc G) Game_import E G}
   `{V' : ValidPackage (loc G') Game_import E G'}
diff --git a/theories/Crypt/nominal/NominalPrelude.v b/theories/Crypt/nominal/NominalPrelude.v
index 13ab422..2113653 100644
--- a/theories/Crypt/nominal/NominalPrelude.v
+++ b/theories/Crypt/nominal/NominalPrelude.v
@@ -138,26 +138,18 @@ Notation "[ f ] ' p { e }" :=
   format "[ f ]  ' p  { '[' '/'  e  '/' ']' }")
   : package_scope.
 
-Notation "y ← 'call' [ f ] : { A ~> B } x ;; c" :=
-  (opr (mkopsig f A B) x (λ y, c))
-  (at level 100, x at next level, right associativity,
-  format "y  ←  call  [ f ]  :  { A  ~>  B }  x  ;;  '//' c")
+Notation "'call' [ f ] : { A ~> B } x" :=
+  (opr (mkopsig f A B) x (λ y, ret y))
+  (at level 99, x at next level, right associativity,
+  format "call  [ f ]  :  { A  ~>  B }  x")
   : package_scope.
 
-Notation "y ← 'call' [ f ] x ;; c" :=
-  (opr (mkopsig f _ _) x (λ y, c))
-  (at level 100, x at next level, right associativity,
-  format "y  ←  call  [ f ]  x  ;;  '//' c")
+Notation "'call' [ f ] x" :=
+  (opr (mkopsig f _ _) x (λ y, ret y))
+  (at level 99, x at next level, right associativity,
+  format "call  [ f ]  x")
   : package_scope.
 
-Notation "' p ← 'call' [ f ] : { A ~> B } x ;; c" :=
-  (opr (mkopsig f A B) x (λ p, c))
-  (at level 100, p pattern, x at next level, right associativity,
-  format "' p  ←  call  [ f ]  :  { A  ~>  B }  x  ;;  '//' c")
-  : package_scope.
-
-Notation "' p ← 'call' [ f ] x ;; c" :=
-  (opr (mkopsig f _ _) x (λ p, c))
-  (at level 100, p pattern, x at next level, right associativity,
-  format "' p  ←  call  [ f ]  x  ;;  '//' c")
-  : package_scope.
+Notation Package I E P := (ValidPackage (loc P) I E P%sep).
+Notation Adversary I P := (ValidPackage (loc P) I A_export P %sep).
+Notation Game E P := (ValidPackage (loc P) Game_import E P%sep).
diff --git a/theories/Crypt/nominal/Pr.v b/theories/Crypt/nominal/Pr.v
index d24df89..c4be903 100644
--- a/theories/Crypt/nominal/Pr.v
+++ b/theories/Crypt/nominal/Pr.v
@@ -62,6 +62,10 @@ Section DistrLemmas.
     \dlet_(y <- dunit v) f y = f v.
   Proof. apply distr_ext, dlet_unit. Qed.
 
+  Lemma dfst_dlet_commut (t : distr R T) (f : T → distr R (U * V)%type) :
+    dfst (\dlet_(x <- t) f x) = \dlet_(x <- t) dfst (f x).
+  Proof. apply distr_ext => ?. by rewrite dmarginE dlet_dlet. Qed.
+
   Lemma dlet_dlet_ext {t : distr R T}
     {f1 : T → distr R U} {f2 : U → distr R V} :
     \dlet_(x <- \dlet_(y <- t) f1 y) f2 x
@@ -77,6 +81,7 @@ Section DistrLemmas.
   Proof. intros H. by apply distr_ext, dlet_f_equal. Qed.
 End DistrLemmas.
 
+
 Section PrCodeLemmas.
   Lemma Pr_Pr_code {G} :
     Pr G = dfst (Pr_code (resolve G RUN tt) empty_heap).
@@ -129,6 +134,99 @@ Section PrCodeLemmas.
   Proof. rewrite Pr_code_sample dlet_null_ext //. Qed.
 End PrCodeLemmas.
 
+Notation dist c := (code emptym [interface] c).
+
+Section PrFstLemmas.
+  Definition Pr_fst {T} (c : raw_code T) : distr R T
+    := dfst (Pr_code c emptym).
+
+  Lemma Pr_fst_ret {A : choiceType} {x : A} :
+    Pr_fst (ret x) = dunit x.
+  Proof. rewrite /Pr_fst Pr_code_ret /(dfst _) dlet_unit_ext //. Qed.
+
+  Lemma Pr_fst_sample {A : choiceType} {op' : Op} {k : Arit op' → raw_code A} :
+    Pr_fst (x ← sample op' ;; k x) = \dlet_(x <- op'.π2) Pr_fst (k x).
+  Proof.  rewrite /Pr_fst Pr_code_sample /(dfst _) dlet_dlet_ext //. Qed.
+
+  Lemma Pr_Pr_fst {G} :
+    Pr G true = Pr_fst (resolve G RUN tt) true.
+  Proof.
+    unfold Pr, SDistr_bind, SDistr_unit, Pr_op, Pr_fst, dfst.
+    by apply dlet_f_equal => [[b h]].
+  Qed.
+
+  Lemma Pr_code_fst {T T' : choiceType} {c} {f : T → raw_code T'} {h}
+    : ValidCode emptym [interface] c
+    → Pr_code (x ← c ;; f x) h
+    = \dlet_(x <- Pr_fst c) Pr_code (f x) h.
+  Proof.
+    elim.
+    2-4: intros; exfalso; eapply fhas_empty; eassumption.
+    - intros x => /=.
+      rewrite /Pr_fst Pr_code_ret /(dfst _) 2!dlet_unit_ext //.
+    - intros op k VA IH => /=.
+      rewrite /Pr_fst 2!Pr_code_sample 2!dlet_dlet_ext.
+      f_equal; extensionality x.
+      rewrite IH dlet_dlet_ext //.
+  Qed.
+
+  Lemma Pr_fst_bind {T T' : choiceType} {c} {f : T → raw_code T'}
+    : ValidCode emptym [interface] c
+    → Pr_fst (x ← c ;; f x)
+    = \dlet_(x <- Pr_fst c) Pr_fst (f x).
+  Proof.
+    intros VA.
+    rewrite /Pr_fst Pr_code_fst 2!dmarginE 2!dlet_dlet_ext.
+    by rewrite /Pr_fst dmarginE dlet_dlet_ext.
+  Qed.
+End PrFstLemmas.
+
+Section LosslessCodeLemmas.
+  Context {A : choiceType}.
+
+  Class LosslessCode (c : raw_code A) :=
+    lossless : psum (Pr_fst c) = 1%R.
+
+  #[export] Instance Lossless_ret (a : A)
+    : LosslessCode (ret a).
+  Proof.
+    rewrite /LosslessCode Pr_fst_ret.
+    apply Couplings.psum_SDistr_unit.
+  Qed.
+
+  #[export] Instance Lossless_sample D (k : _ → raw_code A)
+    : LosslessOp D
+    → (∀ x, LosslessCode (k x))
+    → LosslessCode (x ← sample D ;; k x).
+  Proof.
+    intros H IH. unfold LosslessCode.
+    rewrite Pr_fst_sample.
+    under eq_psum.
+    { intros x. rewrite dletE. over. }
+    rewrite interchange_psum.
+    2: intros x; apply summable_mu_wgtd; intros y.
+    2: apply /andP; split; [ done | apply le1_mu1 ].
+    2: eapply eq_summable.
+    2: intros x; rewrite -dletE; reflexivity.
+    2: apply summable_mu.
+    rewrite -H.
+    apply eq_psum => x.
+    rewrite psumZ // IH GRing.mulr1 //.
+  Qed.
+
+  #[export] Instance Lossless_if b (c1 c2 : raw_code A) :
+    LosslessCode c1 → LosslessCode c2 → LosslessCode (if b then c1 else c2).
+  Proof. by destruct b. Qed.
+
+  Lemma Pr_fstC {T : choiceType} {c : raw_code A} {mu : distr R T}
+    : LosslessCode c → \dlet_(_ <- Pr_fst c) mu = mu.
+  Proof.
+    intros Hpsum. apply distr_ext => ?.
+    by rewrite dletC pr_predT Hpsum GRing.mul1r.
+  Qed.
+End LosslessCodeLemmas.
+
+
 (* Code as nominal *)
 
 #[non_forgetful_inheritance]
diff --git a/theories/Crypt/nominal/Sep.v b/theories/Crypt/nominal/Sep.v
index 660a26f..3aadc60 100644
--- a/theories/Crypt/nominal/Sep.v
+++ b/theories/Crypt/nominal/Sep.v
@@ -194,14 +194,17 @@ Qed.
 (* sep_link *)
 
 Definition sep_link (P P' : nom_package)
-  := share_link P (move P P').
+  := locked (share_link P (move P P')).
 
 Notation "p1 ∘ p2" :=
   (sep_link p1 p2) (right associativity, at level 20) : sep_scope.
 
+Lemma sep_linkE P P' : sep_link P P' = share_link P (move P P').
+Proof. by rewrite /sep_link -lock. Qed.
+
 Add Parametric Morphism : sep_link with
   signature alpha ==> alpha ==> alpha as sep_link_mor.
-Proof. eauto 6 with nominal_db. Qed.
+Proof. intros. rewrite 2!sep_linkE. eauto 6 with nominal_db. Qed.
 
 Lemma valid_sep_link_weak :
   ∀ I M1 M2 E P1 P2,
@@ -209,7 +212,7 @@ Lemma valid_sep_link_weak :
     ValidPackage (loc P2) I M2 P2 →
     fsubmap M1 M2 →
     ValidPackage (loc (P1 ∘ P2)%sep) I E (P1 ∘ P2)%sep.
-Proof. intros.
+Proof. intros. rewrite sep_linkE.
   eapply valid_link_weak.
   1,4: eassumption.
   1: unfold move; by apply rename_valid.
@@ -228,8 +231,7 @@ Lemma share_link_sep_link {P P' : nom_package} :
   disj P P' →
   (P ∘ P')%share ≡ (P ∘ P').
 Proof.
-  intros D.
-  unfold sep_link, move.
+  intros D. rewrite sep_linkE /move.
   auto with nominal_db nocore.
 Qed.
 
@@ -246,21 +248,21 @@ Qed.
 Lemma sep_link_id {I E} P `{ValidPackage (loc P) I E P}
   : P ∘ ID I ≡ P.
 Proof.
-  rewrite /sep_link /move -{3}(share_link_id P).
+  rewrite sep_linkE /move -{3}(share_link_id P).
   eauto with nominal_db nocore.
 Qed.
 
 Lemma id_sep_link {I E} P `{V : ValidPackage (loc P) I E P}
   : ID E ∘ P ≡ P.
 Proof.
-  rewrite /sep_link /move id_share_link.
+  rewrite sep_linkE /move id_share_link.
   eauto with nominal_db nocore.
 Qed.
 
 Lemma sep_link_assoc (p1 p2 p3 : nom_package)
   : p1 ∘ p2 ∘ p3 ≡ (p1 ∘ p2) ∘ p3.
 Proof.
-  rewrite /sep_link /move (equi2_use _ equi_share_link) share_link_assoc.
+  rewrite 4!sep_linkE /move (equi2_use _ equi_share_link) share_link_assoc.
   eauto 20 with nominal_db nocore.
 Qed.
 
@@ -268,16 +270,18 @@ Qed.
 (* sep_par *)
 
 Definition sep_par (P P' : nom_package)
-  := share_par P (move P P').
+  := locked (share_par P (move P P')).
 
 Notation "p1 || p2" :=
   (sep_par p1 p2) : sep_scope.
 
+Lemma sep_parE P P' : sep_par P P' = share_par P (move P P').
+Proof. by rewrite /sep_par -lock. Qed.
+
 Add Parametric Morphism : sep_par with
   signature alpha ==> alpha ==> alpha as sep_par_mor.
 Proof.
-  intros P P' EP Q Q' EQ.
-  unfold sep_par, move.
+  intros. rewrite 2!sep_parE /move.
   auto with nominal_db nocore.
 Qed.
 
@@ -288,7 +292,7 @@ Lemma valid_sep_par {I1 I2 E1 E2} {p1 p2 : nom_package} :
   ValidPackage (loc (p1 || p2)%sep)
     (unionm I1 I2) (unionm E1 E2) (p1 || p2)%sep.
 Proof.
-  intros. unfold sep_par. apply valid_par; try done.
+  intros. rewrite sep_parE. apply valid_par; try done.
   1: unfold move; by apply rename_valid.
   apply fseparate_compat.
   rewrite fseparate_disj //=.
@@ -305,8 +309,7 @@ Lemma share_par_sep_par {P P' : nom_package} :
   disj P P' →
   (P || P')%share ≡ (P || P').
 Proof.
-  intros D.
-  unfold sep_par, move.
+  intros D. rewrite sep_parE /move.
   auto with nominal_db nocore.
 Qed.
 
@@ -353,7 +356,7 @@ Qed.
 Lemma sep_par_commut (p1 p2 : nom_package)
   : fseparate (val p1) (val p2) → (p1 || p2) ≡ (p2 || p1).
 Proof.
-  intros H. unfold sep_par, move.
+  intros H. rewrite 2!sep_parE /move.
   rewrite share_par_commut.
   all: auto with nominal_db nocore.
 Qed.
@@ -361,7 +364,7 @@ Qed.
 Lemma sep_par_assoc {P1 P2 P3 : nom_package}
   : (P1 || (P2 || P3)) ≡ ((P1 || P2) || P3).
 Proof.
-  rewrite /sep_par /move (equi2_use _ equi_share_par) share_par_assoc.
+  rewrite 4!sep_parE /move (equi2_use _ equi_share_par) share_par_assoc.
   auto with nominal_db nocore.
 Qed.
 
@@ -372,7 +375,7 @@ Lemma sep_interchange {A B C D E F} (p1 p2 p3 p4 : nom_package)
   (p1 ∘ p3) || (p2 ∘ p4) ≡ (p1 || p2) ∘ (p3 || p4).
 Proof.
   intros  P34.
-  rewrite /sep_par /sep_link /move
+  rewrite 3!sep_parE 3!sep_linkE /move
     (equi2_use _ equi_share_par) (equi2_use _ equi_share_link) share_interchange.
   all: auto 10 with nominal_db nocore.
 Qed.
diff --git a/theories/Crypt/nominal/packages/Async.v b/theories/Crypt/nominal/packages/Async.v
new file mode 100644
index 0000000..b4a4dda
--- /dev/null
+++ b/theories/Crypt/nominal/packages/Async.v
@@ -0,0 +1,259 @@
+From Coq Require Import Utf8.
+Set Warnings "-ambiguous-paths,-notation-overridden,-notation-incompatible-format".
+From mathcomp Require Import all_ssreflect all_algebra reals distr realsum.
+Set Warnings "ambiguous-paths,notation-overridden,notation-incompatible-format".
+From extructures Require Import ord fset fmap ffun fperm.
+Require Import Equations.Prop.DepElim.
+From Equations Require Import Equations.
+
+From SSProve.Crypt Require Import Axioms SubDistr pkg_composition
+  Prelude Package Nominal NominalPrelude.
+
+From HB Require Import structures.
+
+(* Supress warnings due to use of HB *)
+Set Warnings "-redundant-canonical-projection,-projection-no-head-constant".
+
+Set Bullet Behavior "Strict Subproofs".
+Set Default Goal Selector "!".
+Set Primitive Projections.
+
+Import PackageNotation.
+#[local] Open Scope package_scope.
+
+Section Async.
+  Definition PRIME := 55%N.
+  Definition TRIGGER := 56%N.
+
+  Context (T' T : choice_type).
+  Context (c : T' → dist T).
+  Context (LL : ∀ t, LosslessCode (c t)).
+
+  Definition I_ASYNC :=
+    [interface
+      [ PRIME  ] : { T' ~> 'unit } ;
+      [ TRIGGER ] : { 'unit ~> T }
+    ].
+
+  Definition eager_loc : Location := mkloc 53 (None : option T).
+  Definition lazy_loc : Location := mkloc 53 (None : option T').
+
+  Definition EAGER :
+    game I_ASYNC :=
+    [package [fmap eager_loc ] ;
+      [ PRIME ] : { T' ~> 'unit } (t) {
+        r ← c t ;;
+        #put eager_loc := Some r ;;
+        ret tt
+      } ;
+      [ TRIGGER ] : { 'unit ~> T } 'tt {
+        r ← getSome eager_loc ;;
+        #put eager_loc := None ;;
+        ret r
+      }
+    ].
+
+  Definition LAZY :
+    game I_ASYNC :=
+    [package [fmap lazy_loc ] ;
+      [ PRIME ] : { T' ~> 'unit } (t) {
+        #put lazy_loc := Some t ;;
+        ret tt
+      } ;
+      [ TRIGGER ] : { 'unit ~> T } 'tt {
+        t ← getSome lazy_loc ;;
+        #put lazy_loc := None ;;
+        r ← c t ;;
+        ret r
+      }
+    ].
+
+  Definition ASYNC b := if b then EAGER else LAZY.
+
+  Lemma neq_fst {L L' : Locations} {l l' : Location}
+    : fseparate L L' → fhas L l → fhas L' l' → l.1 != l'.1.
+  Proof.
+    move=> HSEP HL HL'.
+    move: (notin_has_separate _ _ _ HL HSEP) => /negP Hdomm.
+    apply /eqP => Heq. apply Hdomm. rewrite Heq. by apply fhas_in.
+  Qed.
+
+  Definition tape {U} : option T' → (option T → distr R U) → distr R U := λ o f,
+    match o with
+    | None => f None
+    | Some t => \dlet_(x <- Pr_fst (c t)) f (Some x)
+    end.
+
+  Lemma set_set h v1 v2 :
+    set_heap (set_heap h lazy_loc v1) eager_loc v2 = set_heap h eager_loc v2.
+  Proof.
+    rewrite /set_heap. apply eq_fmap => x. rewrite 3!setmE.
+    simpl. by destruct (x == 53%N)%B.
+  Qed.
+
+  Lemma ASYNC_0 LA (A : raw_code bool) h :
+    ValidCode LA I_ASYNC A →
+    fseparate LA [fmap eager_loc] →
+    fseparate LA [fmap lazy_loc] →
+    dfst (tape (get_heap h lazy_loc) (λ y, Pr_code (code_link A EAGER) (set_heap h eager_loc y)))
+      = dfst (Pr_code (code_link A LAZY) h).
+  Proof.
+    intros VA SEP1 SEP2.
+    move: h; induction VA => h; cbn [code_link].
+    - destruct (get_heap h lazy_loc) => /=.
+      + rewrite Pr_code_ret 2!dmarginE dlet_unit_ext /=.
+        rewrite dlet_dlet_ext.
+        under eq_dlet. { intros ?. rewrite Pr_code_ret dlet_unit_ext /=. over. }
+        by rewrite Pr_fstC.
+      + by rewrite 2!Pr_code_ret 2!dmarginE 2!dlet_unit_ext.
+    - rewrite Pr_code_bind.
+      fmap_invert H.
+      + simplify_linking.
+        destruct (get_heap h lazy_loc) => /=.
+        * rewrite bind_assoc.
+          under eq_dlet. {
+            intros ?. rewrite Pr_code_fst.
+            under eq_dlet. {
+              intros ?. rewrite Pr_code_put set_heap_contract. over. }
+            over. }
+          rewrite /= Pr_fstC. 
+          rewrite Pr_code_put Pr_code_ret dlet_unit_ext /=.
+          specialize (H1 tt (set_heap h lazy_loc (Some x))).
+          rewrite -H1 get_set_heap_eq /=.
+          f_equal. symmetry.
+          apply eq_dlet => ?. by rewrite set_set.
+        * rewrite bind_assoc Pr_code_fst.
+          under eq_dlet. {
+            intros ?. rewrite Pr_code_put set_heap_contract.
+            over. }
+          rewrite /= Pr_code_put Pr_code_ret dlet_unit_ext /=.
+          specialize (H1 tt (set_heap h lazy_loc (Some x))).
+          rewrite -H1 get_set_heap_eq /=.
+          f_equal. apply eq_dlet => ?. by rewrite set_set.
+      + simplify_linking.
+        destruct x.
+        rewrite Pr_code_get.
+        destruct (get_heap h lazy_loc) => /=.
+        * under eq_dlet. { intros ?.
+            rewrite Pr_code_get get_set_heap_eq /=.
+            rewrite Pr_code_put set_heap_contract. over. }
+          rewrite Pr_code_put Pr_code_fst. symmetry.
+          rewrite dlet_dlet_ext.
+          under eq_dlet. { intros ?.
+            rewrite Pr_code_ret dlet_unit_ext /=. over. }
+          rewrite 2!dmarginE dlet_dlet_ext. symmetry.
+          rewrite dlet_dlet_ext. apply eq_dlet => t.
+          specialize (H1 t (set_heap h lazy_loc None)).
+          rewrite 2!dmarginE get_set_heap_eq /= in H1.
+          by rewrite -H1 set_set.
+        * rewrite Pr_code_get get_set_heap_eq /=.
+          rewrite Pr_code_sample /= dlet_null_ext.
+          by rewrite Pr_code_fail dlet_null_ext.
+    - rewrite Pr_code_get -H1.
+      epose proof (neq_fst SEP2 H).
+      assert (l.1 != lazy_loc.1). { apply H2. fmap_solve. }
+      destruct (get_heap h lazy_loc); cbn [tape].
+      + under eq_dlet. { intros ?.
+          rewrite Pr_code_get.
+          rewrite get_set_heap_neq //.
+          over. }
+        done.
+      + rewrite Pr_code_get.
+        by rewrite get_set_heap_neq.
+    - rewrite Pr_code_put -IHVA.
+      epose proof (neq_fst SEP2 H).
+      assert (lazy_loc.1 != l.1). { rewrite eq_sym. apply H0. fmap_solve. }
+      rewrite get_set_heap_neq //.
+      destruct (get_heap h lazy_loc); cbn [tape].
+      + under eq_dlet. { intros ?. rewrite Pr_code_put set_heap_commut //. over. }
+        done.
+      + by rewrite Pr_code_put set_heap_commut.
+    - rewrite Pr_code_sample.
+      destruct (get_heap h lazy_loc) eqn:E; cbn [tape].
+      + rewrite 2!dfst_dlet_commut.
+        under eq_dlet. { intros ?. rewrite Pr_code_sample dfst_dlet_commut. over. }
+        rewrite dlet_commut. apply eq_dlet => v.
+        specialize (H0 v h). rewrite -H0. rewrite E. cbn [tape].
+        by rewrite dfst_dlet_commut.
+      + rewrite Pr_code_sample 2!dfst_dlet_commut.
+        apply eq_dlet => v.
+        specialize (H0 v h). rewrite -H0 E.
+        by cbn [tape].
+  Qed.
+
+  Lemma ASYNC_0_Adv LA (A : raw_package) :
+    ValidPackage LA I_ASYNC A_export A →
+    fseparate LA [fmap eager_loc] →
+    fseparate LA [fmap lazy_loc] →
+    Pr (A ∘ EAGER) true = Pr (A ∘ LAZY) true.
+  Proof.
+    intros VA SEP1 SEP2.
+    rewrite 2!Pr_Pr_code 2!resolve_link.
+    assert (H : fhas A_export RUN); [ fmap_solve |].
+    pose proof (valid_resolve _ _ _ _ RUN tt VA H).
+    rewrite -(ASYNC_0 _ _ empty_heap H0 SEP1 SEP2).
+    rewrite get_empty_heap /heap_init /lazy_loc. cbn [mkloc snd projT2 tape].
+
+    f_equal.
+    assert (HNone : get_heap empty_heap eager_loc = None).
+    { by rewrite get_empty_heap. }
+    move: empty_heap HNone.
+    induction H0 => h HNone; cbn [code_link].
+    - by rewrite 2!Pr_code_ret 2!dmarginE 2!dlet_unit_ext.
+    - rewrite Pr_code_bind.
+      fmap_invert H0.
+      + simplify_linking.
+        rewrite Pr_code_fst dlet_dlet_ext. symmetry.
+        rewrite bind_assoc Pr_code_fst.
+        rewrite 2!dfst_dlet_commut. apply eq_dlet => x'.
+        rewrite Pr_code_put. symmetry. rewrite Pr_code_put Pr_code_ret.
+        by rewrite dlet_unit_ext set_heap_contract.
+      + simplify_linking.
+        destruct x.
+        rewrite Pr_code_get HNone /= Pr_code_fail dlet_null_ext.
+        rewrite Pr_code_get get_set_heap_eq Pr_code_sample /=.
+        by rewrite dlet_null_ext.
+    - epose proof (neq_fst SEP2 H0).
+      assert (l.1 != lazy_loc.1). { apply H3. fmap_solve. }
+      rewrite 2!Pr_code_get get_set_heap_neq; auto.
+    - rewrite 2!Pr_code_put.
+      epose proof (neq_fst SEP1 H0).
+      assert (eager_loc.1 != l.1). { rewrite eq_sym. apply H2. fmap_solve. }
+      rewrite set_heap_commut; auto.
+      apply IHvalid_code.
+      by rewrite get_set_heap_neq.
+    - rewrite 2!Pr_code_sample 2!dfst_dlet_commut. apply eq_dlet.
+      intros ?. by apply H1.
+  Qed.
+
+  Lemma Adv_nom_ind (G G' A : nom_package) I {P : R → Type} :
+    (∀ (A' : raw_package) LA, ValidPackage LA I A_export A' →
+      val A ≡ A' →
+      fseparate LA (loc G) →
+      fseparate LA (loc G') →
+      P (AdvantageE G G' A')
+    ) →
+    ValidPackage (loc A) I A_export A →
+    P (Adv G G' A).
+  Proof.
+    intros HP VA.
+    pose (π := fresh ((G, loc G), (G', loc G')) (loc A, A)).
+    replace (Adv G G' A) with (AdvantageE G G' (π ∙ A : nom_package)).
+    2: rewrite -{2}(@rename_alpha _ A π) //.
+    2: rewrite AdvE {1}/Pr' -link_sep_link.
+    3: eauto with nominal_db.
+    2: rewrite {1}/Pr' -link_sep_link //.
+    2: eauto with nominal_db.
+    eapply HP.
+    1: eapply rename_valid; apply VA.
+    1: symmetry; apply rename_alpha.
+    1,2: rewrite fseparate_disj ; eauto with nominal_db.
+  Qed.
+
+  Lemma ASYNC_perfect : perfect (I_ASYNC) EAGER LAZY.
+  Proof.
+    intros A VA. eapply Adv_nom_ind; [| apply VA].
+    intros A' LA VA' _ SEP1 SEP2.
+    by rewrite /AdvantageE ASYNC_0_Adv // GRing.subrr Num.Theory.normr0.
+  Qed.
+End Async.
diff --git a/theories/Crypt/nominal/packages/HybridArgument.v b/theories/Crypt/nominal/packages/HybridArgument.v
new file mode 100644
index 0000000..ae19b06
--- /dev/null
+++ b/theories/Crypt/nominal/packages/HybridArgument.v
@@ -0,0 +1,218 @@
+From Coq Require Import Utf8 Lia.
+Set Warnings "-ambiguous-paths,-notation-overridden,-notation-incompatible-format".
+From mathcomp Require Import all_ssreflect all_algebra.
+From mathcomp Require Import ssrnat ssreflect ssrfun ssrbool ssrnum eqtype
+  choice reals distr seq all_algebra fintype realsum order.
+Set Warnings "ambiguous-paths,notation-overridden,notation-incompatible-format".
+From extructures Require Import ord fset fmap ffun fperm.
+Require Import Equations.Prop.DepElim.
+From Equations Require Import Equations.
+
+From SSProve.Crypt Require Import Axioms SubDistr pkg_composition
+  Prelude Package Nominal NominalPrelude TotalProbability.
+
+From HB Require Import structures.
+
+(* Supress warnings due to use of HB *)
+Set Warnings "-redundant-canonical-projection,-projection-no-head-constant".
+
+Set Bullet Behavior "Strict Subproofs".
+Set Default Goal Selector "!".
+Set Primitive Projections.
+
+Import PackageNotation.
+#[local] Open Scope package_scope.
+
+
+Definition unif (n : nat) : dist nat := {code
+  x ← sample uniform n ;; ret (x : nat) }.
+
+Lemma eq_sum_sum {n} {F : nat → R} :
+  (\sum_i F (@nat_of_ord n i)
+  = \sum_(0 <= i < n) F i)%R.
+Proof.
+  induction n.
+  - rewrite big_nil big_ord0 //.
+  - by rewrite big_ord_recr big_nat_recr //= IHn.
+Qed.
+
+Lemma dlet_uniform {Y : choiceType} {n} `{Hlt : Lt 0 n}
+  {f : _ → distr R Y} {y : Y} :
+  (\dlet_(x <- (uniform n).π2) f x) y = ((\sum_x f x y) / n%:~R)%R.
+Proof.
+  rewrite dletE psum_fin.
+  rewrite GRing.mulr_suml.
+  apply eq_bigr => /= i _.
+  rewrite /UniformDistrLemmas.r card_ord /=.
+  rewrite GRing.mul1r GRing.mulrC.
+  rewrite Num.Theory.ger0_norm //.
+  apply Num.Theory.mulr_ge0 => //.
+  rewrite Num.Theory.invr_ge0.
+  rewrite ler0z //.
+Qed.
+
+Lemma Pr_RAND_unif {n} {A} `{ValidPackage (loc A) (IPICK nat) A_export A} :
+  (Pr' (A ∘ RAND (unif n)) true *+ n
+      = \sum_(0 <= i < n) Pr' (A ∘ @CONST nat i) true)%R.
+Proof.
+  destruct n.
+  1: rewrite GRing.mulr0n big_nil //.
+  rewrite -> TotalProbability; try exact _.
+  rewrite Pr_fst_sample dlet_dlet.
+  under dlet_f_equal.
+  1: intros x; rewrite Pr_fst_ret; rewrite dlet_unit_ext; over.
+  rewrite dlet_uniform.
+  rewrite -eq_sum_sum.
+  rewrite -(GRing.Theory.mulr_natr (_ / _)%R n.+1).
+  rewrite -GRing.mulrA.
+  rewrite GRing.mulVf ?GRing.mulr1 //.
+  apply /eqP => H0.
+  erewrite <- GRing.mul0rn in H0.
+  apply Num.Theory.pmulrnI in H0 => //.
+  move: (GRing.oner_eq0 R) => /eqP //.
+Qed.
+
+Lemma Adv_CONST_hybrid {I} {n} {A R R'}
+  `{VA  : ValidPackage (loc A) I A_export A}
+  `{VR  : ValidPackage (loc R) (IPICK nat) I R}
+  `{VR' : ValidPackage (loc R') (IPICK nat) I R'}
+  : (∀ i, i < n → perfect I (R' ∘ CONST i) (R ∘ CONST i.+1))
+  → (Adv (R ∘ CONST 0%N) (R ∘ CONST n) A
+  = Adv (R ∘ RAND (unif n)) (R' ∘ RAND (unif n)) A *+ n)%R.
+Proof.
+  intros IH.
+  do 2 (rewrite -> Adv_sym; symmetry).
+  rewrite 2!AdvE -Num.Theory.normrMn.
+  rewrite <- (@GRing.mulr_natr Axioms.R).
+  rewrite GRing.mulrBl.
+  do 2 rewrite -> (@GRing.mulr_natr Axioms.R).
+  symmetry.
+  do 2 (rewrite -> sep_link_assoc, Pr_RAND_unif).
+  rewrite <- (GRing.telescope_sumr (fun i => Pr' (A ∘ R ∘ CONST i) true)) => //.
+  rewrite GRing.sumrB.
+  do 2 f_equal.
+  - rewrite 2!big_nat.
+    apply eq_bigr => i /andP [_ H].
+    rewrite <- sep_link_assoc.
+    by apply perfect_Pr, IH.
+  - f_equal. apply eq_bigr => i _.
+    by rewrite <- sep_link_assoc.
+Qed.
+
+#[local] Open Scope ring_scope.
+#[local] Open Scope nat_scope.
+
+(*
+Lemma Adv_hybrid {IMULTI IGAME} {n : nat}
+  {MULTI GAME : bool → nom_package} {H A}
+  `{VA : Adversary IMULTI A}
+  `{VG : ∀ b, Game IGAME (GAME b)}
+  `{VH : Package
+    (unionm IGAME (IPICK nat)) IMULTI H}
+  : perfect IMULTI (MULTI true)
+      (H ∘ (GAME true || CONST 0))
+  → perfect IMULTI (MULTI false)
+      (H ∘ (GAME true || CONST n))
+  → (∀ i : nat, i < n →
+      perfect IMULTI
+        (H ∘ (GAME false || CONST i ))
+        (H ∘ (GAME true  || CONST i.+1)))
+  → AdvOf MULTI A =
+      AdvOf GAME (A ∘ H ∘
+        (ID IGAME || RAND (unif n))) *+ n.
+ *)
+
+Theorem Adv_hybrid {IMULTI IGAME} {n : nat}
+  {MULTI GAME : bool → nom_package} {H A} `{VA : Adversary IMULTI A}
+  `{VG : ∀ b, Game IGAME (GAME b)} `{VH : Package (unionm IGAME (IPICK nat)) IMULTI H}
+  : perfect IMULTI (MULTI true) (H ∘ (GAME true || CONST 0))
+  → perfect IMULTI (MULTI false) (H ∘ (GAME true || CONST n))
+  → (∀ i : nat, i < n →
+      perfect IMULTI (H ∘ (GAME false || CONST i )) (H ∘ (GAME true  || CONST i.+1)))
+  → AdvOf MULTI A = AdvOf GAME (A ∘ H ∘ (ID IGAME || RAND (unif n))) *+ n.
+Proof.
+  intros p p' p''.
+  rewrite (Adv_perfect_l p) (Adv_perfect_r p').
+  rewrite (sep_par_factor_game_l _ (CONST 0)).
+  rewrite (sep_par_factor_game_l _ (CONST n)).
+  rewrite 2!sep_link_assoc.
+  erewrite @Adv_CONST_hybrid.
+  5: {
+    intros i; specialize (p'' i).
+    rewrite (sep_par_factor_game_l _ (CONST i)) in p''.
+    rewrite (sep_par_factor_game_l _ (CONST i.+1)) in p''.
+    do 2 rewrite -> sep_link_assoc in p''.
+    exact p''.
+  }
+  2-4: ssprove_valid.
+  do 2 rewrite <- sep_link_assoc.
+  erewrite <- sep_par_factor_game_l.
+  2,3: ssprove_valid.
+  erewrite <- sep_par_factor_game_l.
+  2,3: ssprove_valid.
+  rewrite (sep_par_factor_game_r (GAME true)).
+  rewrite (sep_par_factor_game_r (GAME false)).
+  rewrite 2!Adv_reduction sep_link_assoc //.
+Qed.
+
+Lemma Adv_hybrid_dep {IGame} {n : nat} {Multi : bool → nom_package}
+  {Game : nat → bool → nom_package} {A}
+  `{VA : ValidPackage (loc A) IGame A_export A}
+  `{VG : ∀ n b, ValidPackage (loc (Game n b)) [interface] IGame (Game n b)}
+  : perfect IGame (Multi true) (Game 0 true)
+  → perfect IGame (Multi false) (Game n true)
+  → (∀ i : 'nat, i < n → perfect IGame (Game i false) (Game i.+1 true))
+  → (AdvOf Multi A <= \sum_(0 <= i < n) AdvOf (Game i) A)%R.
+Proof.
+  intros p p' p''.
+  rewrite (Adv_perfect_l p) (Adv_perfect_r p').
+  elim: {-2}n (leqnn n).
+  - intros ?. rewrite Adv_same big_nil //.
+  - intros j IH H'.
+    rewrite big_nat_recr //=.
+    ssprove_hop (Game j true)%sep.
+    rewrite -(Adv_perfect_r (p'' j H')) //.
+    apply ltnW in H'.
+    apply Num.Theory.lerD; auto.
+Qed.
+
+
+Ltac replace_true e :=
+  progress ( replace e with true in * by (symmetry; (apply /ltP || apply /eqP); lia) ).
+
+Ltac replace_false e :=
+  progress ( replace e with false in * by (symmetry; (apply /ltP || apply /eqP); lia) ).
+
+Lemma hybrid_cases (c i : nat) (T : Type) :
+  ((c < i)%coq_nat → T) →
+  ((c = i) → T) →
+  ((c = i.+1) → T) →
+  ((c > i.+1)%coq_nat → T) →
+  T.
+Proof.
+  intros H1 H2 H3 H4.
+  destruct (c < i)%N eqn:E1; move: E1 => /ltP // E1.
+  destruct (c == i)%B eqn:E2; move: E2 => /eqP // E2.
+  destruct (c == i.+1)%B eqn:E3; move: E3 => /eqP // E3.
+  destruct (c > i.+1)%N eqn:E4; move: E4 => /ltP // E4. lia.
+Qed.
+
+Ltac replace_next :=
+  match goal with
+  | |- context[ (?n <= ?m)%N ] =>
+      try replace_true (n <= m)%N ;
+      try replace_false (n <= m)%N
+  | |- context[ (?n == ?m :> nat)%B ] =>
+      try replace_true (n == m :> nat)%B ;
+      try replace_false (n == m :> nat)%B
+  end.
+
+Ltac replace_many := repeat replace_next.
+
+Ltac hybrid_cases c i :=
+  apply (hybrid_cases c i) => ? ;
+  [ replace_many
+  | subst ; replace_many
+  | subst ; replace_many
+  | replace_many
+  ].
diff --git a/theories/Crypt/nominal/packages/TotalProbability.v b/theories/Crypt/nominal/packages/TotalProbability.v
new file mode 100644
index 0000000..8391e97
--- /dev/null
+++ b/theories/Crypt/nominal/packages/TotalProbability.v
@@ -0,0 +1,222 @@
+From Coq Require Import Utf8.
+Set Warnings "-ambiguous-paths,-notation-overridden,-notation-incompatible-format".
+From mathcomp Require Import all_ssreflect all_algebra reals distr realsum.
+Set Warnings "ambiguous-paths,notation-overridden,notation-incompatible-format".
+From extructures Require Import ord fset fmap ffun fperm.
+Require Import Equations.Prop.DepElim.
+From Equations Require Import Equations.
+
+From SSProve.Crypt Require Import Axioms SubDistr pkg_composition
+  Prelude Package Nominal NominalPrelude.
+
+From HB Require Import structures.
+
+(* Supress warnings due to use of HB *)
+Set Warnings "-redundant-canonical-projection,-projection-no-head-constant".
+
+Set Bullet Behavior "Strict Subproofs".
+Set Default Goal Selector "!".
+Set Primitive Projections.
+
+Import PackageNotation.
+#[local] Open Scope package_scope.
+
+
+(* PICK game *)
+
+Definition PICK := 57.
+
+Definition IPICK T :=
+  [interface [ PICK ] : { unit ~> T }].
+
+Definition CONST {T : choice_type} (x : T)
+  : game (IPICK T) :=
+  [package emptym ;
+    [ PICK ] (_) {
+      ret x
+    } ].
+
+Definition cell T : Location := mkloc 58 (None : 'option T).
+
+Definition RAND {T : choice_type} (c : dist T)
+  : game (IPICK T) :=
+  [package [fmap cell T] ;
+    [ PICK ] (_) {
+      mr ← get cell T ;;
+      if mr is Some r then
+        ret r
+      else
+        r ← c ;;
+        #put cell T := Some r ;;
+        ret r
+    } ].
+
+
+Section TotalProbability.
+
+Context {T : choice_type}.
+Context (c : dist T).
+
+
+Lemma Pr_code_RAND_Some {LA} {T'} {A : raw_code T'} {f f' : T} {h} :
+  fseparate LA [fmap cell T] →
+  ValidCode LA (IPICK T) A →
+  get_heap h (cell T) = Some f' →
+  Pr_code (code_link A (RAND c)) h
+  = Pr_code (code_link A (RAND {code ret f})) h.
+Proof.
+  intros SEP VA.
+  move: h; induction (VA) => h H'.
+  - done.
+  - fmap_invert H.
+    destruct x.
+    cbn [code_link].
+    simplify_linking.
+    rewrite 2!Pr_code_get H'.
+    cbn [code_link bind].
+    by apply H1.
+  - cbn[code_link].
+    rewrite 2!Pr_code_get.
+    by apply H1.
+  - cbn [code_link].
+    rewrite 2!Pr_code_put.
+    erewrite IHv => //.
+    rewrite get_set_heap_neq //.
+    apply fhas_in in H.
+    destruct SEP as [SEP].
+    move: SEP => /fdisjointP.
+    intros H''.
+    specialize (H'' _ H).
+    rewrite domm_set domm0 in H''.
+    apply /negP.
+    move=> /eqP H'''.
+    rewrite H''' in H''.
+    rewrite in_fsetU in_fset1 eq_refl // in H''.
+  - cbn [code_link].
+    rewrite 2!Pr_code_sample.
+    apply eq_dlet => x.
+    by apply H0.
+Qed.
+
+Lemma Pr_code_RAND {LA} {T'} {A : raw_code T'} {h} :
+  fseparate LA [fmap cell T] →
+  LosslessCode c →
+  ValidCode LA (IPICK T) A →
+  get_heap h (cell T) = None →
+  Pr_code (code_link A (RAND c)) h
+    = \dlet_(f <- Pr_fst c) Pr_code (code_link A (RAND {code ret f})) h.
+Proof.
+  intros SEP LL VA H'.
+  apply distr_ext.
+  move: h H'; induction VA.
+  - intros h H' y.
+    rewrite Pr_code_ret.
+    rewrite dletC pr_predT LL GRing.mul1r //.
+  - intros h H' y.
+    fmap_invert H.
+    destruct x.
+    cbn [bind code_link].
+    simplify_linking.
+    rewrite Pr_code_get H'.
+    rewrite bind_assoc.
+    rewrite Pr_code_fst.
+    apply dlet_f_equal => x.
+    rewrite Pr_code_put.
+    simplify_linking.
+    rewrite Pr_code_get H'.
+    cbn [bind].
+    rewrite Pr_code_put.
+    erewrite Pr_code_RAND_Some.
+    + reflexivity.
+    + apply SEP.
+    + apply H0.
+    + rewrite get_set_heap_eq //.
+  - intros h H' y.
+    cbn [code_link].
+    rewrite Pr_code_get.
+    rewrite H1 //.
+  - intros h H' y.
+    cbn [code_link].
+    rewrite Pr_code_put.
+    rewrite IHVA //.
+    rewrite get_set_heap_neq //.
+    move: (notin_has_separate _ _ _ H SEP) => /dommPn H0.
+    apply /eqP => H''.
+    by rewrite -H'' in H0.
+  - intros h H' y.
+    cbn [code_link].
+    rewrite Pr_code_sample.
+    under eq_in_dlet.
+    1: intros ? ? ?; rewrite H0 //; reflexivity.
+    1: reflexivity.
+    symmetry.
+    under eq_in_dlet.
+    1: intros ? ? ?; rewrite Pr_code_sample //.
+    1: reflexivity.
+    rewrite dlet_commut //.
+Qed.
+
+Lemma Pr_RAND {LA} {A : raw_package} :
+  fseparate LA [fmap cell T] →
+  LosslessCode c →
+  ValidPackage LA (IPICK T) A_export A →
+  Pr (A ∘ RAND c) = \dlet_(x <- Pr_fst c) Pr (A ∘ RAND {code ret x}).
+Proof.
+  intros SEP LL VA. apply distr_ext => b.
+  rewrite /Pr /SDistr_bind /SDistr_unit /Pr_op resolve_link.
+  assert (H : fhas A_export RUN); [ fmap_solve |].
+  pose proof (valid_resolve _ _ _ _ RUN tt VA H).
+  rewrite (Pr_code_RAND SEP LL H0).
+  2: rewrite get_empty_heap //.
+  rewrite dlet_dlet.
+  apply dlet_f_equal => y.
+  rewrite resolve_link => //.
+Qed.
+
+Lemma CONST_dirac_perfect (x : T) :
+  perfect (IPICK T) (RAND {code ret x}) (CONST x).
+Proof.
+  eapply prove_perfect.
+  apply (eq_rel_perf_ind _ _ (heap_ignore [fmap cell T]
+    ⋊ single_lhs (cell T) (λ v, v = None ∨ v = Some x)) ).
+  { ssprove_invariant. by left. }
+  simplify_eq_rel m.
+  destruct m => /=.
+  ssprove_code_simpl; simpl.
+  apply r_get_remember_lhs => y.
+  ssprove_rem_rel 0.
+  elim => ?; subst.
+  - apply r_put_lhs.
+    ssprove_restore_mem. { ssprove_invariant. }
+    by apply r_ret.
+  - apply r_forget_lhs.
+    by apply r_ret.
+Qed.
+
+End TotalProbability.
+
+#[local] Open Scope sep_scope.
+
+Theorem TotalProbability {T : choice_type}
+  (c : dist T) `{LosslessCode T c}
+  {A} `{Adversary (IPICK T) A} :
+  Pr' (A ∘ RAND c) true =
+    (\dlet_(x <- Pr_fst c)
+      Pr' (A ∘ CONST x)) true.
+Proof.
+  pose (π := fresh (as_nom (RAND c), [fmap cell T] : Locations) (A, loc A)).
+  rewrite -{1}(@rename_alpha _ A π).
+  rewrite {1}/Pr' -link_sep_link.
+  2: eauto with nominal_db.
+  rewrite Pr_RAND.
+  2: rewrite fseparate_disj; eauto with nominal_db.
+  rewrite 2!dletE.
+  apply eq_psum => x.
+  f_equal.
+  rewrite -(perfect_Pr (CONST_dirac_perfect _)).
+  rewrite -{2}(@rename_alpha _ A π).
+  rewrite {1}/Pr' -link_sep_link // /disj.
+  change (supp (as_nom (RAND {code ret x})))
+    with (supp ([fmap cell T] : Locations)).
+  eauto with nominal_db.
+Qed.
diff --git a/theories/Crypt/package/pkg_user_util.v b/theories/Crypt/package/pkg_user_util.v
index 75d375e..ee691da 100644
--- a/theories/Crypt/package/pkg_user_util.v
+++ b/theories/Crypt/package/pkg_user_util.v
@@ -693,18 +693,12 @@ Ltac remember_pre_fold :=
 
 Ltac ssprove_restore_pre :=
   update_pre_fold ;
-  eapply r_restore_pre ; [
-    cbn
-  | idtac
-  ].
+  eapply r_restore_pre.
 
 Ltac ssprove_restore_mem :=
   update_pre_fold ;
   remember_pre_fold ;
-  eapply r_restore_mem ; [
-    cbn
-  | idtac
-  ].
+  eapply r_restore_mem.
 
 Ltac get_heap_simpl :=
   repeat
